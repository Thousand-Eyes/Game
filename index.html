<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è³½å±€æ¨¹æ±‚è§£å™¨ V3.4.2 (ç¯„æœ¬ç”Ÿæˆç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: "Noto Sans TC", sans-serif; overflow: hidden; touch-action: none; background-color: #f8fafc; }
        
        .tree { display: flex; justify-content: center; padding: 50px 100px 300px 100px; transform-origin: center top; }
        .tree-node-container { display: flex; flex-direction: column; align-items: center; position: relative; padding: 0 10px; } 
        .children-container { display: flex; flex-direction: row; justify-content: center; margin-top: 60px; }

        .node-wrapper { display: flex; flex-direction: column; align-items: center; position: relative; z-index: 10; }
        .node-box {
            background: white;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            cursor: grab; 
            touch-action: none;
            transition: box-shadow 0.3s ease;
        }
        .node-box:active { cursor: grabbing; }
        .node-decision { border: 3px solid #3b82f6; border-radius: 9999px; padding: 8px 16px; min-width: 90px; text-align: center; }
        .node-terminal { border: 3px solid #ef4444; border-radius: 12px; padding: 8px; min-width: 100px; }
        
        .highlight-equilibrium { box-shadow: 0 0 25px rgba(34, 197, 94, 0.9); border-color: #22c55e !important; background-color: #f0fdf4; font-weight: bold; }

        input.dynamic-width {
            background: rgba(255, 255, 255, 0.95);
            text-align: center;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            outline: none;
            min-width: 50px;
            padding: 2px 6px;
            font-size: 11px;
            margin-bottom: 4px;
        }

        #svg-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        path.connection { fill: none; stroke: #cbd5e1; stroke-width: 2; }
        path.equilibrium-path { stroke: #22c55e; stroke-width: 5; stroke-dasharray: 15; animation: flow 1s linear infinite; z-index: 5; }
        path.off-path-optimal { stroke: #86efac; stroke-width: 3; stroke-dasharray: 5, 5; }
        @keyframes flow { to { stroke-dashoffset: -30; } }
        
        .modal-overlay { background-color: rgba(0,0,0,0.5); position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; z-index: 50; padding: 1rem; }
        .modal-active { display: flex; }
        .loader { border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3b82f6; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .analysis-text h3 { font-size: 1.1rem; font-weight: 800; color: #4f46e5; margin-top: 1rem; margin-bottom: 0.5rem; border-left: 4px solid #4f46e5; padding-left: 8px; }
        .analysis-text p { margin-bottom: 0.75rem; line-height: 1.6; }
    </style>
</head>
<body class="h-screen flex flex-col text-slate-800 bg-slate-50">

    <!-- Header -->
    <header class="bg-white border-b border-slate-200 px-4 py-3 flex flex-col lg:flex-row justify-between items-center shadow-sm z-30 shrink-0">
        <div class="flex items-center gap-3 mb-3 lg:mb-0 w-full lg:w-auto justify-center lg:justify-start">
            <div class="p-2 bg-gradient-to-br from-indigo-600 to-blue-700 rounded-lg text-white shadow-md flex-shrink-0">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5c0-5.523 4.477-10 10-10z"/><path d="M8.5 8.5a2.5 2.5 0 0 0-2.5 2.5H5a4 5 0 0 0 0 9h6a4 5 0 0 0 0-9h-1a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
            </div>
            <div>
                <h1 class="text-lg md:text-xl font-bold text-slate-900 leading-tight">AI è³½å±€æ¨¹æ±‚è§£å™¨ <span class="text-blue-600 text-[10px] md:text-xs px-1 border border-blue-200 rounded align-middle">V3.4.2</span></h1>
                <p class="text-[10px] md:text-xs text-slate-500 hidden sm:block">ç¯„æœ¬ç”Ÿæˆ | è‡ªå‹•ç¸®æ”¾èˆ‡æ‹–æ›³ | æ·±åº¦ç­–ç•¥è§£æ</p>
            </div>
        </div>

        <div class="grid grid-cols-2 sm:flex sm:flex-wrap gap-2 w-full lg:w-auto justify-center">
            <button onclick="openAiModal()" class="px-3 py-2 text-sm font-bold text-white bg-indigo-600 rounded-full shadow hover:bg-indigo-700 transition-all flex items-center justify-center gap-1">
                <span>ğŸ¤– AI ç”Ÿæˆ</span>
            </button>
            
            <button onclick="analyzeGameWithAI()" class="px-3 py-2 text-sm font-bold text-white bg-amber-500 rounded-full shadow hover:bg-amber-600 transition-all flex items-center justify-center gap-1">
                <span>âœ¨ ç­–ç•¥åˆ†æ</span>
            </button>

            <button onclick="openSettings()" class="px-3 py-2 text-xs md:text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center gap-1">
                è¨­å®š
            </button>
            
            <button onclick="saveGame()" class="px-3 py-2 text-xs md:text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center gap-1">
                å„²å­˜
            </button>
            
            <label class="px-3 py-2 text-xs md:text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center gap-1 cursor-pointer">
                åŒ¯å…¥
                <input type="file" id="fileInput" accept=".json" class="hidden" onchange="importGame(this)">
            </label>

            <button onclick="solveGame()" class="col-span-2 sm:col-span-1 px-4 py-2 text-sm font-bold text-white bg-green-600 rounded shadow hover:bg-green-700 flex items-center justify-center gap-1">
                è¨ˆç®—è·¯å¾‘
            </button>
        </div>
    </header>

    <!-- Main Canvas -->
    <main class="flex-1 relative overflow-hidden bg-slate-50">
        <div id="canvas-container" class="w-full h-full overflow-hidden relative cursor-grab active:cursor-grabbing">
            <svg id="svg-layer"></svg>
            <div id="tree-root" class="tree min-w-max min-h-max transform transition-transform duration-75 origin-top-center">
                <!-- Tree Injected Here -->
            </div>
        </div>

        <div class="absolute bottom-6 right-6 z-20 flex gap-2">
             <button onclick="manualZoom(-0.1)" class="w-10 h-10 flex items-center justify-center bg-white rounded-full shadow border border-slate-200 text-slate-600 font-bold">-</button>
             <button onclick="resetZoom()" class="px-3 h-10 bg-white rounded-full shadow border border-slate-200 text-xs font-bold text-slate-600 flex items-center">100%</button>
             <button onclick="manualZoom(0.1)" class="w-10 h-10 flex items-center justify-center bg-white rounded-full shadow border border-slate-200 text-slate-600 font-bold">+</button>
        </div>
    </main>

    <!-- AI Generation Modal -->
    <div id="ai-modal" class="modal-overlay">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-[500px] max-w-full m-4 border-t-4 border-indigo-600">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-slate-800 flex items-center gap-2">ğŸ¤– AI è³½å±€å»ºæ¨¡</h2>
                <button onclick="closeAiModal()" class="text-slate-400 hover:text-slate-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg></button>
            </div>
            <div class="space-y-4">
                <p class="text-xs text-slate-500 bg-blue-50 p-2 rounded">æœ¬ç‰ˆæœ¬å·²æ•´åˆç’°å¢ƒé‡‘é‘°ï¼Œæ‚¨ç„¡éœ€è¼¸å…¥ API Key å³å¯ç›´æ¥ä½¿ç”¨ã€‚</p>
                <textarea id="ai-prompt" rows="6" placeholder="è«‹æè¿°æƒ…å¢ƒ... ä¾‹å¦‚ï¼šæˆ‘æ˜¯å¤–åŒ…å•†ï¼Œå®¢æˆ¶çªç„¶è¦æ±‚ç¸®çŸ­å·¥æœŸä½†ä¸åŠ éŒ¢ï¼Œè‹¥æˆ‘æ‹’çµ•å¯èƒ½æœƒå¤±å»æœªä¾†è¨‚å–®..." class="w-full px-3 py-2 border border-slate-300 rounded text-sm focus:ring-2 focus:ring-indigo-500 outline-none resize-none"></textarea>
                <button id="ai-generate-btn" onclick="generateGameFromAI()" class="w-full py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 flex justify-center items-center gap-2">
                    <span id="ai-btn-text">é–‹å§‹ç”Ÿæˆè³½å±€</span>
                    <div id="ai-spinner" class="loader hidden"></div>
                </button>
                <p id="ai-error-msg" class="text-xs text-red-500 text-center hidden"></p>
            </div>
        </div>
    </div>

    <!-- Analysis Result Modal -->
    <div id="analysis-modal" class="modal-overlay">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-[600px] max-w-full max-h-[85vh] m-4 border-t-4 border-amber-500 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-slate-800 flex items-center gap-2">âœ¨ AI ç­–ç•¥è§£æå ±å‘Š</h2>
                <button onclick="closeAnalysisModal()" class="text-slate-400 hover:text-slate-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg></button>
            </div>
            <div id="analysis-content" class="analysis-text flex-1 bg-slate-50 p-4 rounded-lg border border-slate-200 overflow-y-auto text-sm"></div>
            <div class="mt-4 flex justify-end"><button onclick="closeAnalysisModal()" class="px-4 py-2 bg-slate-200 text-slate-700 font-bold rounded hover:bg-slate-300">é—œé–‰å ±å‘Š</button></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-96 max-w-full m-4">
            <h2 class="text-xl font-bold text-slate-800 mb-4">è³½å±€è¨­å®š</h2>
            <div class="mb-4">
                <label class="block text-sm font-bold text-slate-600 mb-2">ç©å®¶æ•¸é‡</label>
                <div class="flex items-center gap-3">
                    <button onclick="changePlayerCount(-1)" class="w-8 h-8 rounded bg-slate-100 font-bold text-slate-600">-</button>
                    <span id="player-count-display" class="text-xl font-bold text-indigo-600 w-8 text-center">2</span>
                    <button onclick="changePlayerCount(1)" class="w-8 h-8 rounded bg-slate-100 font-bold text-slate-600">+</button>
                </div>
            </div>
            <div id="player-names-list" class="space-y-2 max-h-48 overflow-y-auto mb-6"></div>
            <div class="flex justify-end gap-2 border-t pt-4"><button onclick="closeSettings()" class="px-4 py-2 text-sm text-slate-500">å–æ¶ˆ</button><button onclick="applySettings()" class="px-4 py-2 bg-indigo-600 text-white text-sm font-bold rounded">å„²å­˜å¥—ç”¨</button></div>
        </div>
    </div>

    <span id="text-measurer" style="position:absolute; visibility:hidden; white-space:nowrap; font-size:11px; padding:2px 6px;"></span>

    <!-- JS Logic -->
    <script>
        const apiKey = ""; 
        const modelName = "gemini-2.5-flash-preview-09-2025";
        
        async function callGeminiAPI(payload) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
            let delay = 1000;
            for (let i = 0; i < 5; i++) {
                try {
                    const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (response.ok) { const data = await response.json(); return data.candidates?.[0]?.content?.parts?.[0]?.text; }
                    if (response.status !== 429 && response.status !== 503) { const err = await response.json(); throw new Error(err.error?.message || "API Error"); }
                } catch (err) { if (i === 4) throw err; }
                await new Promise(res => setTimeout(res, delay)); delay *= 2;
            }
        }

        const CONFIG = { colors: ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'] };
        let gameConfig = { playerCount: 2, playerNames: ["ç©å®¶ 1", "ç©å®¶ 2"] };
        class Node {
            constructor(id, parentId = null) {
                this.id = id; this.parentId = parentId; this.playerIdx = 0; this.children = [];
                this.payoffs = Array(gameConfig.playerCount).fill(0); this.bestChildId = null; 
                this.description = ""; this.isOnEquilibriumPath = false; this.dx = 0; this.dy = 0;
            }
        }
        let treeData = null, scale = 1, isPan = false, panStartX, panStartY, scrollLeft, scrollTop, draggingNodeId = null, nodeDragStartX, nodeDragStartY, initialNodeDx, initialNodeDy, initialPinchDistance = 0, initialScale = 1;

        function init() { treeData = new Node('root'); addChild(treeData); addChild(treeData); renderTree(); setupEventListeners(); }

        function setupEventListeners() {
            const container = document.getElementById('canvas-container');
            container.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            container.addEventListener('wheel', onWheel, { passive: false });
            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onTouchEnd);
        }

        function onMouseDown(e) {
            if (e.target.closest('button') || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;
            const nodeWrapper = e.target.closest('.node-wrapper');
            if (nodeWrapper) { startNodeDrag(nodeWrapper.id.replace('node-wrapper-', ''), e.clientX, e.clientY); return; }
            isPan = true; panStartX = e.clientX; panStartY = e.clientY; scrollLeft = document.getElementById('canvas-container').scrollLeft; scrollTop = document.getElementById('canvas-container').scrollTop;
        }
        function onMouseMove(e) {
            if (draggingNodeId) { e.preventDefault(); updateNodeDrag(e.clientX, e.clientY); }
            else if (isPan) { const c = document.getElementById('canvas-container'); c.scrollLeft = scrollLeft - (e.clientX - panStartX); c.scrollTop = scrollTop - (e.clientY - panStartY); }
        }
        function onMouseUp() { isPan = false; draggingNodeId = null; }
        function onWheel(e) { e.preventDefault(); manualZoom(e.deltaY > 0 ? -0.1 : 0.1); }
        function onTouchStart(e) {
            if (e.target.closest('button') || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;
            e.preventDefault();
            if (e.touches.length === 2) { initialPinchDistance = getDistance(e.touches[0], e.touches[1]); initialScale = scale; }
            else { const touch = e.touches[0]; const nw = e.target.closest('.node-wrapper'); if (nw) startNodeDrag(nw.id.replace('node-wrapper-', ''), touch.clientX, touch.clientY); else { isPan = true; panStartX = touch.clientX; panStartY = touch.clientY; scrollLeft = document.getElementById('canvas-container').scrollLeft; scrollTop = document.getElementById('canvas-container').scrollTop; } }
        }
        function onTouchMove(e) {
            if (e.touches.length === 2) { const dist = getDistance(e.touches[0], e.touches[1]); scale = Math.max(0.3, Math.min(2.5, initialScale + (dist - initialPinchDistance) * 0.005)); applyZoom(); }
            else if (draggingNodeId) updateNodeDrag(e.touches[0].clientX, e.touches[0].clientY);
            else if (isPan) { const c = document.getElementById('canvas-container'); c.scrollLeft = scrollLeft - (e.touches[0].clientX - panStartX); c.scrollTop = scrollTop - (e.touches[0].clientY - panStartY); }
        }
        function onTouchEnd() { isPan = false; draggingNodeId = null; }
        function getDistance(t1, t2) { return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2)); }
        function startNodeDrag(id, x, y) { draggingNodeId = id; nodeDragStartX = x; nodeDragStartY = y; const n = findNode(treeData, id); initialNodeDx = n.dx; initialNodeDy = n.dy; }
        function updateNodeDrag(x, y) { const n = findNode(treeData, draggingNodeId); n.dx = initialNodeDx + (x - nodeDragStartX)/scale; n.dy = initialNodeDy + (y - nodeDragStartY)/scale; document.getElementById(`node-wrapper-${draggingNodeId}`).style.transform = `translate(${n.dx}px, ${n.dy}px)`; requestAnimationFrame(drawConnections); }
        function manualZoom(d) { scale = Math.max(0.3, Math.min(2.5, scale + d)); applyZoom(); }
        function resetZoom() { scale = 1; applyZoom(); }
        function applyZoom() { document.getElementById('tree-root').style.transform = `scale(${scale})`; requestAnimationFrame(drawConnections); }

        async function generateGameFromAI() {
            const prompt = document.getElementById('ai-prompt').value.trim();
            if (!prompt) return;
            const btn = document.getElementById('ai-generate-btn'); const spinner = document.getElementById('ai-spinner'); const error = document.getElementById('ai-error-msg');
            btn.disabled = true; spinner.classList.remove('hidden'); error.classList.add('hidden');
            
            // SCHEMA LOCKING START: Using ChangeLife.json as the one-shot template
            const exampleSchema = {
                "version": "3.4.2",
                "timestamp": "ISO_DATE",
                "config": {
                    "playerCount": 2,
                    "playerNames": ["P1 (Role)", "P2 (Role)"]
                },
                "tree": {
                    "id": "root",
                    "parentId": null,
                    "playerIdx": 0,
                    "description": "Situation description",
                    "payoffs": [0, 0],
                    "children": [
                        {
                            "id": "L1_ActionA",
                            "parentId": "root",
                            "playerIdx": 1,
                            "description": "Action A description",
                            "payoffs": [10, -5],
                            "children": []
                        }
                    ]
                }
            };

            const sys = `You are a Game Theory Expert. Analyze the user scenario and output ONLY valid JSON matching this exact schema structure:
            ${JSON.stringify(exampleSchema)}
            
            RULES:
            1. Output JSON ONLY. No markdown blocks.
            2. Follow the nesting structure of 'children' for the game tree.
            3. 'playerIdx' is 0-based.
            4. 'payoffs' must be an array of numbers.
            5. Create meaningful depth (at least 3 levels recommended for interesting games).`;
            // SCHEMA LOCKING END

            try {
                const text = await callGeminiAPI({ contents: [{ parts: [{ text: sys + "\n\nUser Scenario: " + prompt }] }] });
                const clean = text.replace(/```json/g, '').replace(/```/g, '').trim();
                const data = JSON.parse(clean); gameConfig = data.config; treeData = restoreNodePrototype(data.tree); solveGame(); closeAiModal();
            } catch (err) { error.textContent = "ç”Ÿæˆå¤±æ•—: " + err.message; error.classList.remove('hidden'); }
            finally { btn.disabled = false; spinner.classList.add('hidden'); }
        }

        async function analyzeGameWithAI() {
            const modal = document.getElementById('analysis-modal'); const content = document.getElementById('analysis-content');
            modal.classList.add('modal-active'); content.innerHTML = '<div class="flex justify-center items-center h-40"><div class="loader"></div><p class="ml-2 text-slate-500">å¤§å¸«æ­£åœ¨æ¨æ¼”å±€å‹¢...</p></div>';
            solveGame();
            const sys = `ä½ æ˜¯ä¸€ä½ç²¾é€šè³½å±€ç†è«–çš„è»å¸«ã€‚åˆ†ææ­¤ JSON æ ¼å¼è³½å±€ï¼ˆå«ç´è¨±å‡è¡¡è·¯å¾‘ï¼‰ã€‚ä½¿ç”¨ç¹é«”ä¸­æ–‡ Markdown è¼¸å‡ºï¼š
            1. **å±€å‹¢ç¸½çµ**
            2. **å‡è¡¡è·¯å¾‘åˆ†æ** (ç‚ºä½•é€™æ˜¯ç†æ€§é¸æ“‡)
            3. **ç•°å¸¸é¢¨éšª** (è‹¥å°æ‰‹ä¸æŒ‰ç‰Œç†å‡ºç‰Œ)
            4. **è‡´å‹å»ºè­°**`;
            try {
                const json = JSON.stringify({ config: gameConfig, tree: treeData });
                const text = await callGeminiAPI({ contents: [{ parts: [{ text: sys + "\n\nGame Data: " + json }] }] });
                content.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/^#+\s+(.*$)/gm, '<h3>$1</h3>').replace(/\n/g, '<br>');
            } catch (err) { content.innerHTML = `<p class="text-red-500">åˆ†æå¤±æ•—: ${err.message}</p>`; }
        }

        function findNode(n, id) { if (n.id === id) return n; for (let c of n.children) { let f = findNode(c, id); if (f) return f; } return null; }
        function restoreNodePrototype(n) { n.isOnEquilibriumPath = false; if (n.dx === undefined) n.dx = 0; if (n.dy === undefined) n.dy = 0; if (n.children) n.children.forEach(restoreNodePrototype); if (n.payoffs.length !== gameConfig.playerCount) { const p = Array(gameConfig.playerCount).fill(0); n.payoffs.forEach((v, i) => { if (i < p.length) p[i] = v; }); n.payoffs = p; } return n; }
        function solveGame() { clearSol(treeData); backwardInduction(treeData); tracePath(treeData); renderTree(); }
        function clearSol(n) { n.bestChildId = null; n.isOnEquilibriumPath = false; n.children.forEach(clearSol); }
        function backwardInduction(n) { if (n.children.length === 0) return [...n.payoffs]; let bestV = -Infinity, bestP = null, bestId = null, idx = n.playerIdx; for (let c of n.children) { let res = backwardInduction(c); if (res[idx] > bestV) { bestV = res[idx]; bestP = res; bestId = c.id; } else if (bestV === -Infinity) { bestV = res[idx]; bestP = res; bestId = c.id; } } n.bestChildId = bestId; return bestP; }
        function tracePath(n) { n.isOnEquilibriumPath = true; if (n.bestChildId) { let c = n.children.find(x => x.id === n.bestChildId); if (c) tracePath(c); } }
        function addChild(p) { const id = 'n-' + Math.random().toString(36).substr(2, 9); const n = new Node(id, p.id); n.description = `é¸é … ${p.children.length + 1}`; n.playerIdx = (p.playerIdx + 1) % gameConfig.playerCount; p.children.push(n); renderTree(); }
        function removeNode(id, pid) { if (!pid) return; const p = findNode(treeData, pid); p.children = p.children.filter(c => c.id !== id); renderTree(); }
        function updateNodeData(id, t, v, i = 0) { const n = findNode(treeData, id); if (!n) return; if (t === 'desc') n.description = v; else if (t === 'playerIdx') n.playerIdx = parseInt(v); else if (t === 'payoff') n.payoffs[i] = parseFloat(v) || 0; if (t !== 'desc') { clearSol(treeData); renderTree(); } }
        function adjustWidth(input) { const m = document.getElementById('text-measurer'); m.textContent = input.value || input.placeholder; input.style.width = Math.max(50, m.offsetWidth + 12) + 'px'; }

        function renderTree() { const root = document.getElementById('tree-root'); root.innerHTML = ''; root.appendChild(buildNodeDOM(treeData)); requestAnimationFrame(drawConnections); }
        function buildNodeDOM(node) {
            const container = document.createElement('div'); container.className = 'tree-node-container'; container.id = `node-container-${node.id}`;
            const wrap = document.createElement('div'); wrap.className = 'node-wrapper'; wrap.id = `node-wrapper-${node.id}`; wrap.style.transform = `translate(${node.dx}px, ${node.dy}px)`;
            wrap.onmousedown = (e) => startNodeDrag(node.id, e.clientX, e.clientY); wrap.ontouchstart = (e) => { if(e.touches.length===1) startNodeDrag(node.id, e.touches[0].clientX, e.touches[0].clientY); };
            
            if (node.parentId) { const lbl = document.createElement('input'); lbl.value = node.description; lbl.className = "dynamic-width"; setTimeout(() => adjustWidth(lbl), 0); lbl.oninput = (e) => { adjustWidth(e.target); updateNodeData(node.id, 'desc', e.target.value); }; lbl.onmousedown = (e) => e.stopPropagation(); lbl.ontouchstart = (e) => e.stopPropagation(); wrap.appendChild(lbl); }
            const box = document.createElement('div'); box.className = 'node-box ' + (node.children.length === 0 ? 'node-terminal ' : 'node-decision ') + (node.isOnEquilibriumPath ? 'highlight-equilibrium' : ''); box.id = `node-visual-${node.id}`;
            
            if (node.children.length > 0) {
                const color = CONFIG.colors[node.playerIdx % CONFIG.colors.length];
                let opts = ''; gameConfig.playerNames.forEach((name, i) => opts += `<option value="${i}" ${node.playerIdx === i ? 'selected' : ''}>${name}</option>`);
                box.style.borderColor = color;
                box.innerHTML = `<div class="mb-1"><select onchange="updateNodeData('${node.id}', 'playerIdx', this.value)" class="bg-transparent font-bold text-sm text-center outline-none" style="color: ${color}" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">${opts}</select></div><div class="flex justify-center mt-1 pt-1 border-t border-slate-100"><button onclick="addChild(findNode(treeData, '${node.id}'))" class="text-xs text-blue-600 px-1" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">+</button>${node.parentId ? `<button onclick="removeNode('${node.id}', '${node.parentId}')" class="text-xs text-red-600 px-1" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">Ã—</button>` : ''}</div>`;
            } else {
                let pays = ''; gameConfig.playerNames.forEach((n, i) => pays += `<div class="flex items-center gap-1 text-[10px] font-bold" style="color:${CONFIG.colors[i % CONFIG.colors.length]}"><span>${n[0]}:</span><input type="number" value="${node.payoffs[i]}" class="editable-payoff w-8" onchange="updateNodeData('${node.id}', 'payoff', this.value, ${i})" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()"></div>`);
                box.innerHTML = `<div class="grid grid-cols-2 gap-1">${pays}</div><div class="flex justify-between mt-1 pt-1 border-t border-slate-100"><button onclick="addChild(findNode(treeData, '${node.id}'))" class="text-[9px] text-blue-500" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">æ“´</button><button onclick="removeNode('${node.id}', '${node.parentId}')" class="text-[9px] text-red-500" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">åˆª</button></div>`;
            }
            wrap.appendChild(box); container.appendChild(wrap);
            if (node.children.length > 0) { const cc = document.createElement('div'); cc.className = 'children-container'; node.children.forEach(c => cc.appendChild(buildNodeDOM(c))); container.appendChild(cc); }
            return container;
        }

        function drawConnections() {
            const svg = document.getElementById('svg-layer'); svg.innerHTML = ''; const container = document.getElementById('canvas-container');
            const getCoords = (id) => { const el = document.getElementById(`node-visual-${id}`); if (!el) return null; const r = el.getBoundingClientRect(), cr = container.getBoundingClientRect(); return { x: r.left - cr.left + container.scrollLeft + r.width/2, y: r.top - cr.top + container.scrollTop + r.height/2, bottom: r.bottom - cr.top + container.scrollTop, top: r.top - cr.top + container.scrollTop }; };
            const draw = (n) => { const pc = getCoords(n.id); if (!pc) return; n.children.forEach(c => { const cc = getCoords(c.id); if (!cc) return; const path = document.createElementNS("http://www.w3.org/2000/svg", "path"); const d = `M ${pc.x} ${pc.bottom} C ${pc.x} ${pc.bottom + (cc.top - pc.bottom)/2}, ${cc.x} ${cc.top - (cc.top - pc.bottom)/2}, ${cc.x} ${cc.top}`; path.setAttribute("d", d); let cls = "connection"; if (n.bestChildId === c.id) cls += n.isOnEquilibriumPath ? " equilibrium-path" : " off-path-optimal"; path.setAttribute("class", cls); svg.appendChild(path); draw(c); }); };
            draw(treeData);
        }

        // Settings Logic - Fixed Bug
        let tempConfig = {};
        function openSettings() {
            tempConfig = JSON.parse(JSON.stringify(gameConfig));
            renderSettingsUI();
            document.getElementById('settings-modal').classList.add('modal-active');
        }
        function renderSettingsUI() {
            const list = document.getElementById('player-names-list'); list.innerHTML = '';
            tempConfig.playerNames.forEach((n, i) => {
                const div = document.createElement('div'); div.className = "flex items-center gap-2";
                div.innerHTML = `<div class="w-4 h-4 rounded-full shrink-0" style="background:${CONFIG.colors[i % CONFIG.colors.length]}"></div><input value="${n}" class="flex-1 border p-1 rounded text-sm outline-none focus:ring-1" oninput="tempConfig.playerNames[${i}]=this.value">`;
                list.appendChild(div);
            });
            document.getElementById('player-count-display').textContent = tempConfig.playerCount;
        }
        function closeSettings() { document.getElementById('settings-modal').classList.remove('modal-active'); }
        function changePlayerCount(d) {
            let newCount = tempConfig.playerCount + d;
            if (newCount < 1) newCount = 1; if (newCount > 6) newCount = 6;
            tempConfig.playerCount = newCount;
            // Sync array
            if (tempConfig.playerNames.length < newCount) {
                for (let i = tempConfig.playerNames.length; i < newCount; i++) tempConfig.playerNames.push(`ç©å®¶ ${i + 1}`);
            } else if (tempConfig.playerNames.length > newCount) {
                tempConfig.playerNames = tempConfig.playerNames.slice(0, newCount);
            }
            renderSettingsUI();
        }
        function applySettings() {
            gameConfig = JSON.parse(JSON.stringify(tempConfig));
            updateTreePayoffs(treeData);
            closeSettings();
            renderTree();
        }
        function updateTreePayoffs(n) {
            const targetLen = gameConfig.playerCount;
            if (n.payoffs.length < targetLen) { for (let i = 0; i < targetLen - n.payoffs.length; i++) n.payoffs.push(0); }
            else if (n.payoffs.length > targetLen) { n.payoffs = n.payoffs.slice(0, targetLen); }
            if (n.playerIdx >= targetLen) n.playerIdx = 0;
            n.children.forEach(updateTreePayoffs);
        }

        // Modals
        function openAiModal() { document.getElementById('ai-modal').classList.add('modal-active'); }
        function closeAiModal() { document.getElementById('ai-modal').classList.remove('modal-active'); }
        function closeAnalysisModal() { document.getElementById('analysis-modal').classList.remove('modal-active'); }
        function saveGame() { const blob = new Blob([JSON.stringify({ config: gameConfig, tree: treeData })], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `gametree_v3.4.2.json`; a.click(); }
        function importGame(input) { const reader = new FileReader(); reader.onload = (e) => { const d = JSON.parse(e.target.result); gameConfig = d.config; treeData = restoreNodePrototype(d.tree); solveGame(); }; reader.readAsText(input.files[0]); }

        window.addEventListener('resize', drawConnections);
        init();
    </script>
</body>
</html>
