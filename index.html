<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- V3.1 Update: Removed user-scalable=no to allow page zooming if needed, optimized for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å‹•æ…‹è³½å±€æ¨¹æ±‚è§£å™¨ V3.1 (RWD+æ‹–æ›³ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: "Noto Sans TC", sans-serif; overflow: hidden; touch-action: none; }
        
        /* æ¨¹ç‹€çµæ§‹ä½ˆå±€æ ¸å¿ƒ */
        .tree { display: flex; justify-content: center; padding-top: 50px; padding-bottom: 200px; padding-left: 50px; padding-right: 50px; }
        .tree-node-container { display: flex; flex-direction: column; align-items: center; position: relative; padding: 0 10px; } 
        .children-container { display: flex; flex-direction: row; justify-content: center; margin-top: 60px; }

        /* V3.1 Update: Node Wrapper for grouping Label + NodeBox */
        .node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 10;
            /* Transform will be applied here */
        }

        /* ç¯€é»æ¨£å¼ */
        .node-box {
            transition: box-shadow 0.3s ease, background-color 0.3s ease;
            background: white;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: grab; 
        }
        .node-box:active {
            cursor: grabbing;
        }
        .node-decision {
            border: 3px solid #3b82f6;
            border-radius: 9999px;
            padding: 8px 16px;
            min-width: 90px;
            text-align: center;
        }
        .node-terminal {
            border: 3px solid #ef4444;
            border-radius: 12px;
            padding: 8px;
            min-width: 100px;
        }
        
        /* é«˜äº®æ¨£å¼ */
        .highlight-equilibrium {
            box-shadow: 0 0 25px rgba(34, 197, 94, 0.9);
            border-color: #22c55e !important;
            background-color: #f0fdf4;
            font-weight: bold;
        }

        /* è¼¸å…¥æ¡†æ¨£å¼ */
        input.dynamic-width {
            background: rgba(255, 255, 255, 0.95);
            text-align: center;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            outline: none;
            transition: all 0.2s;
            min-width: 50px;
            padding: 2px 6px;
            font-size: 11px;
            color: #475569;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            /* V3.1 Update: Margin bottom to separate from node box */
            margin-bottom: 4px;
        }
        input.dynamic-width:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
            z-index: 20;
        }

        input.editable-payoff {
            background: transparent;
            text-align: center;
            border: none;
            border-bottom: 1px dashed #94a3b8;
            outline: none;
            width: 100%;
            transition: border 0.2s;
        }
        input.editable-payoff:focus { border-bottom: 2px solid #3b82f6; }

        /* SVG é€£ç·šå±¤ */
        #svg-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0;
        }
        path.connection {
            fill: none; stroke: #cbd5e1; stroke-width: 2;
        }
        
        path.equilibrium-path {
            stroke: #22c55e; 
            stroke-width: 5;
            stroke-dasharray: 15;
            animation: flow 1s linear infinite;
            z-index: 5;
        }

        path.off-path-optimal {
            stroke: #86efac; 
            stroke-width: 3;
            stroke-dasharray: 5, 5; 
        }

        @keyframes flow { to { stroke-dashoffset: -30; } }
        
        /* UI Elements */
        .modal-overlay {
            background-color: rgba(0,0,0,0.5);
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center; z-index: 50;
            padding: 1rem;
        }
        .modal-active { display: flex; }

        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 20px; height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Collapsible Legend Animation */
        .legend-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            max-height: 200px;
            opacity: 1;
            overflow: hidden;
        }
        .legend-collapsed .legend-content {
            max-height: 0;
            opacity: 0;
        }
        .legend-toggle-icon {
            transition: transform 0.3s ease;
        }
        .legend-collapsed .legend-toggle-icon {
            transform: rotate(-90deg);
        }
    </style>
</head>
<body class="bg-slate-50 h-screen flex flex-col text-slate-800">

    <!-- Header (Responsive) -->
    <header class="bg-white border-b border-slate-200 px-4 py-3 flex flex-col lg:flex-row justify-between items-center shadow-sm z-30 relative">
        <div class="flex items-center gap-3 mb-3 lg:mb-0 w-full lg:w-auto justify-center lg:justify-start">
            <div class="p-2 bg-gradient-to-br from-violet-600 to-fuchsia-600 rounded-lg text-white shadow-md flex-shrink-0">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5c0-5.523 4.477-10 10-10z"/><path d="M8.5 8.5a2.5 2.5 0 0 0-2.5 2.5H5a4 5 0 0 0 0 9h6a4 5 0 0 0 0-9h-1a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
            </div>
            <div>
                <h1 class="text-lg md:text-xl font-bold text-slate-900 leading-tight">AI è³½å±€æ¨¹æ±‚è§£å™¨ <span class="text-violet-600 text-[10px] md:text-xs px-1 border border-violet-200 rounded align-middle">V3.1</span></h1>
                <p class="text-[10px] md:text-xs text-slate-500 hidden sm:block">AI è¼”åŠ©å»ºæ¨¡ | è‡ªç”±æ‹–æ›³ç¯€é» | è‡ªå‹•æœ€ä½³è§£</p>
            </div>
        </div>

        <div class="grid grid-cols-2 sm:flex sm:flex-wrap gap-2 w-full lg:w-auto justify-center">
            <button onclick="openAiModal()" class="col-span-2 sm:col-span-1 px-3 py-2 text-sm font-bold text-white bg-violet-600 rounded-full shadow hover:bg-violet-700 transition-all flex items-center justify-center gap-1 border border-violet-500">
                <span>ğŸ¤– AI ç”Ÿæˆ</span>
            </button>

            <button onclick="openSettings()" class="px-3 py-2 text-xs md:text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded hover:bg-slate-50 transition-colors flex items-center justify-center gap-1">
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                è¨­å®š
            </button>
            
            <button onclick="saveGame()" class="px-3 py-2 text-xs md:text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded hover:bg-slate-50 transition-colors flex items-center justify-center gap-1">
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"/></svg>
                å„²å­˜
            </button>
            <label class="px-3 py-2 text-xs md:text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded hover:bg-slate-50 transition-colors flex items-center justify-center gap-1 cursor-pointer">
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/></svg>
                åŒ¯å…¥
                <input type="file" id="fileInput" accept=".json" class="hidden" onchange="importGame(this)">
            </label>

            <button onclick="solveGame()" class="col-span-2 sm:col-span-1 px-4 py-2 text-sm font-bold text-white bg-green-600 rounded shadow hover:bg-green-700 transition-colors flex items-center justify-center gap-1">
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
                è¨ˆç®—æœ€ä½³è§£
            </button>
        </div>
    </header>

    <!-- Main Canvas -->
    <main class="flex-1 relative overflow-hidden bg-slate-50 flex flex-col">
        
        <!-- Collapsible Legend -->
        <div id="legend-box" class="absolute top-2 left-2 md:top-4 md:left-4 z-20 bg-white/90 rounded-lg border border-slate-200 text-xs shadow-md backdrop-blur-sm transition-all w-48 md:w-56">
            <div class="flex justify-between items-center p-2 cursor-pointer border-b border-slate-100" onclick="toggleLegend()">
                <h3 class="font-bold text-slate-700">åœ–ä¾‹èªªæ˜</h3>
                <svg id="legend-icon" class="w-4 h-4 text-slate-500 legend-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
            </div>
            <div class="legend-content p-2">
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-8 h-1 bg-green-500 rounded"></div>
                    <span>å‡è¡¡è·¯å¾‘ (æ¨è–¦)</span>
                </div>
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-8 h-0 border-t-2 border-green-300 border-dashed"></div>
                    <span>éå‡è¡¡æœ€ä½³åæ‡‰</span>
                </div>
                <div class="text-[10px] text-slate-400 mt-1 leading-tight">
                    æ“ä½œæç¤ºï¼š<br>
                    â€¢ æŒ‰ä½ç¯€é»å¯è‡ªç”±æ‹–æ›³<br>
                    â€¢ æ¨™ç±¤èˆ‡ç¯€é»è‡ªå‹•è·Ÿéš¨<br>
                    â€¢ æ»¾è¼ªç¸®æ”¾ç•«å¸ƒ<br>
                    â€¢ æ”¯æ´æ‰‹æ©Ÿé›™æŒ‡ç¸®æ”¾
                </div>
            </div>
        </div>

        <!-- Canvas Container (Wheel listener added) -->
        <div id="canvas-container" class="canvas-area w-full h-full overflow-hidden relative cursor-grab active:cursor-grabbing" onmousedown="startCanvasDrag(event)" onwheel="handleWheel(event)">
            <svg id="svg-layer"></svg>
            <div id="tree-root" class="tree min-w-max min-h-max transform origin-top transition-transform duration-75">
                <!-- Tree Injected Here -->
            </div>
        </div>

        <!-- Zoom Controls -->
        <div class="absolute bottom-6 right-6 z-20 flex gap-2">
             <button onclick="zoom(-0.1)" class="w-10 h-10 md:w-8 md:h-8 flex items-center justify-center bg-white rounded-full shadow border border-slate-200 hover:bg-slate-50 text-slate-600 font-bold text-lg md:text-base">-</button>
             <button onclick="resetZoom()" class="px-3 h-10 md:h-8 bg-white rounded-full shadow border border-slate-200 hover:bg-slate-50 text-xs font-bold text-slate-600 flex items-center">100%</button>
             <button onclick="zoom(0.1)" class="w-10 h-10 md:w-8 md:h-8 flex items-center justify-center bg-white rounded-full shadow border border-slate-200 hover:bg-slate-50 text-slate-600 font-bold text-lg md:text-base">+</button>
        </div>
    </main>

    <!-- AI Agent Modal -->
    <div id="ai-modal" class="modal-overlay">
        <div class="bg-white rounded-xl shadow-2xl p-4 md:p-6 w-[500px] max-w-full max-h-[90vh] overflow-y-auto m-4 border-t-4 border-violet-600 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg md:text-xl font-bold text-slate-800 flex items-center gap-2">
                    <span class="text-2xl">ğŸ¤–</span> AI è³½å±€åˆ†æå¸«
                </h2>
                <button onclick="closeAiModal()" class="text-slate-400 hover:text-slate-600 p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>

            <div class="space-y-4 flex-1">
                <div class="bg-slate-50 p-3 rounded-lg border border-slate-200">
                    <label class="block text-xs font-bold text-slate-500 mb-1">Google Gemini API Key</label>
                    <input type="password" id="ai-api-key" placeholder="è²¼ä¸Š Key" class="w-full px-3 py-2 border border-slate-300 rounded text-sm focus:outline-none focus:border-violet-500">
                    <p class="text-[10px] text-slate-400 mt-1">
                        <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-violet-600 underline">å–å¾—å…è²» Key</a>
                    </p>
                </div>

                <div>
                    <label class="block text-xs font-bold text-slate-600 mb-1">åˆ†ææ¨¡å‹</label>
                    <select id="ai-model-select" class="w-full px-3 py-2 border border-slate-300 rounded text-sm bg-white focus:outline-none focus:border-violet-500">
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash (å¿«é€Ÿ)</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro (ç²¾ç¢º)</option>
                    </select>
                </div>

                <div>
                    <label class="block text-xs font-bold text-slate-600 mb-1">æƒ…å¢ƒæè¿°</label>
                    <textarea id="ai-prompt" rows="5" placeholder="ä¾‹å¦‚ï¼šæˆ‘ä¸æƒ³é…åˆä¸»ç®¡è²ªç€†ï¼Œæƒ³ä»¥å®¶åº­å› ç´ è«‹èª¿..." class="w-full px-3 py-2 border border-slate-300 rounded text-sm focus:outline-none focus:border-violet-500 resize-none"></textarea>
                </div>

                <button id="ai-generate-btn" onclick="generateGameFromAI()" class="w-full py-3 bg-violet-600 text-white font-bold rounded-lg hover:bg-violet-700 transition-colors flex justify-center items-center gap-2">
                    <span id="ai-btn-text">é–‹å§‹åˆ†æ</span>
                    <div id="ai-spinner" class="loader hidden"></div>
                </button>
                
                <p id="ai-error-msg" class="text-xs text-red-500 text-center hidden"></p>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-96 max-w-full m-4">
            <h2 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"/></path></svg>
                è³½å±€ç©å®¶è¨­å®š
            </h2>
            
            <div class="mb-4">
                <label class="block text-sm font-bold text-slate-600 mb-2">ç©å®¶æ•¸é‡</label>
                <div class="flex items-center gap-3">
                    <button onclick="changePlayerCount(-1)" class="w-8 h-8 rounded bg-slate-100 hover:bg-slate-200 text-slate-600 font-bold">-</button>
                    <span id="player-count-display" class="text-xl font-bold text-blue-600 w-8 text-center">2</span>
                    <button onclick="changePlayerCount(1)" class="w-8 h-8 rounded bg-slate-100 hover:bg-slate-200 text-slate-600 font-bold">+</button>
                </div>
            </div>

            <div class="mb-6">
                <label class="block text-sm font-bold text-slate-600 mb-2">ç©å®¶åç¨±</label>
                <div id="player-names-list" class="space-y-2 max-h-48 overflow-y-auto pr-1">
                    <!-- Dynamic Inputs -->
                </div>
            </div>

            <div class="flex justify-end gap-2 pt-4 border-t border-slate-100">
                <button onclick="closeSettings()" class="px-4 py-2 text-sm text-slate-500 hover:text-slate-700">å–æ¶ˆ</button>
                <button onclick="applySettings()" class="px-4 py-2 bg-blue-600 text-white text-sm font-bold rounded hover:bg-blue-700">å¥—ç”¨</button>
            </div>
        </div>
    </div>

    <span id="text-measurer" style="position:absolute; visibility:hidden; white-space:nowrap; font-size:11px; padding:2px 6px;"></span>

    <!-- JS Logic -->
    <script>
        // --- Configuration & State ---
        const CONFIG = {
            colors: ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'] 
        };

        let gameConfig = {
            playerCount: 2,
            playerNames: ["ç©å®¶ 1", "ç©å®¶ 2"]
        };

        class Node {
            constructor(id, parentId = null) {
                this.id = id;
                this.parentId = parentId;
                this.playerIdx = 0; 
                this.children = [];
                this.payoffs = Array(gameConfig.playerCount).fill(0);
                this.bestChildId = null; 
                this.description = ""; 
                this.isOnEquilibriumPath = false;
                this.dx = 0; 
                this.dy = 0;
            }
        }

        let treeData = null;
        let scale = 1;
        // Interaction State
        let isCanvasDragging = false;
        let draggingNodeId = null;
        let dragStartX, dragStartY;
        let initialNodeDx = 0, initialNodeDy = 0;
        let scrollLeft, scrollTop;

        // --- Initialization ---
        function init() {
            treeData = new Node('root');
            treeData.playerIdx = 0; 
            addChild(treeData);
            addChild(treeData);
            renderTree();
        }

        // --- Legend Toggle ---
        function toggleLegend() {
            const legend = document.getElementById('legend-box');
            legend.classList.toggle('legend-collapsed');
        }

        // --- Dragging Logic ---
        
        const slider = document.getElementById('canvas-container');

        // Canvas Pan
        function startCanvasDrag(e) {
            if(e.target.closest('.node-wrapper') || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') {
                return;
            }
            isCanvasDragging = true;
            slider.classList.add('cursor-grabbing');
            
            const pageX = e.touches ? e.touches[0].pageX : e.pageX;
            const pageY = e.touches ? e.touches[0].pageY : e.pageY;

            dragStartX = pageX - slider.offsetLeft;
            dragStartY = pageY - slider.offsetTop;
            scrollLeft = slider.scrollLeft;
            scrollTop = slider.scrollTop;
        }

        // V3.1 Update: Mouse Wheel Zoom
        function handleWheel(e) {
            // Prevent default page scroll only if scaling
            if (e.ctrlKey || e.metaKey || e.deltaY) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                zoom(delta);
            }
        }

        // Node Drag
        function startNodeDrag(e, nodeId) {
            e.stopPropagation(); 
            draggingNodeId = nodeId;
            
            const node = findNode(treeData, nodeId);
            initialNodeDx = node.dx || 0;
            initialNodeDy = node.dy || 0;

            const pageX = e.touches ? e.touches[0].pageX : e.pageX;
            const pageY = e.touches ? e.touches[0].pageY : e.pageY;

            dragStartX = pageX;
            dragStartY = pageY;
        }

        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, { passive: false });

        function handleMove(e) {
            const pageX = e.touches ? e.touches[0].pageX : e.pageX;
            const pageY = e.touches ? e.touches[0].pageY : e.pageY;

            if (isCanvasDragging) {
                e.preventDefault(); 
                const x = pageX - slider.offsetLeft;
                const y = pageY - slider.offsetTop;
                const walkX = (x - dragStartX); 
                const walkY = (y - dragStartY);
                slider.scrollLeft = scrollLeft - walkX;
                slider.scrollTop = scrollTop - walkY;
            } 
            else if (draggingNodeId) {
                e.preventDefault();
                const deltaX = (pageX - dragStartX) / scale;
                const deltaY = (pageY - dragStartY) / scale;
                
                const node = findNode(treeData, draggingNodeId);
                node.dx = initialNodeDx + deltaX;
                node.dy = initialNodeDy + deltaY;

                // Update visual position of the WRAPPER (label + box)
                const nodeEl = document.getElementById(`node-wrapper-${draggingNodeId}`);
                if (nodeEl) {
                    nodeEl.style.transform = `translate(${node.dx}px, ${node.dy}px)`;
                }
                
                requestAnimationFrame(drawConnections);
            }
        }

        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        function endDrag() {
            isCanvasDragging = false;
            draggingNodeId = null;
            slider.classList.remove('cursor-grabbing');
        }

        // --- AI Agent Logic ---
        function openAiModal() {
            document.getElementById('ai-modal').classList.add('modal-active');
            const savedKey = localStorage.getItem('gemini_api_key');
            if(savedKey) document.getElementById('ai-api-key').value = savedKey;
        }

        function closeAiModal() {
            document.getElementById('ai-modal').classList.remove('modal-active');
            document.getElementById('ai-error-msg').classList.add('hidden');
        }

        async function generateGameFromAI() {
            const apiKey = document.getElementById('ai-api-key').value.trim();
            const promptText = document.getElementById('ai-prompt').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const btnText = document.getElementById('ai-btn-text');
            const spinner = document.getElementById('ai-spinner');
            const errorMsg = document.getElementById('ai-error-msg');

            if (!apiKey) {
                errorMsg.textContent = "è«‹è¼¸å…¥ Google Gemini API Key";
                errorMsg.classList.remove('hidden');
                return;
            }
            if (!promptText) {
                errorMsg.textContent = "è«‹è¼¸å…¥è³½å±€æƒ…å¢ƒæè¿°";
                errorMsg.classList.remove('hidden');
                return;
            }

            localStorage.setItem('gemini_api_key', apiKey);
            btnText.textContent = "AI åˆ†æä¸­...";
            spinner.classList.remove('hidden');
            errorMsg.classList.add('hidden');
            document.getElementById('ai-generate-btn').disabled = true;

            const systemPrompt = `
                You are a Game Theory Expert. Analyze the user's scenario and output a valid JSON representing the game tree.
                RULES:
                1. Output ONLY valid JSON.
                2. Schema: {"config": {"playerCount": number, "playerNames": []}, "tree": {"id": "root", "playerIdx": 0, "payoffs": [], "children": []}}
                3. "playerIdx" 0 based.
                4. Create reasonable structure.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: systemPrompt + "\n\nUser Scenario:\n" + promptText }]
                        }]
                    })
                });

                if (!response.ok) {
                    let errorText = response.statusText;
                    try { const err = await response.json(); if(err.error) errorText = err.error.message; } catch(e){}
                    throw new Error(`API Error (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                const aiText = data.candidates[0].content.parts[0].text;
                const cleanJson = aiText.replace(/```json/g, '').replace(/```/g, '').trim();
                const gameData = JSON.parse(cleanJson);

                if (!gameData.tree || !gameData.config) throw new Error("Data format invalid");

                gameConfig = gameData.config;
                treeData = restoreNodePrototype(gameData.tree);
                
                solveGame();
                closeAiModal();
                alert("AI ç”ŸæˆæˆåŠŸï¼");

            } catch (err) {
                errorMsg.textContent = "Error: " + err.message;
                errorMsg.classList.remove('hidden');
            } finally {
                btnText.textContent = "é–‹å§‹åˆ†æ";
                spinner.classList.add('hidden');
                document.getElementById('ai-generate-btn').disabled = false;
            }
        }

        // --- Save / Load Logic ---

        function saveGame() {
            const data = {
                version: "3.1",
                timestamp: new Date().toISOString(),
                config: gameConfig,
                tree: treeData
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gametree_v3.1_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importGame(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.tree || !data.config) throw new Error("ç„¡æ•ˆçš„æª”æ¡ˆæ ¼å¼");
                    gameConfig = data.config;
                    treeData = restoreNodePrototype(data.tree);
                    solveGame();
                    alert("åŒ¯å…¥æˆåŠŸï¼");
                } catch (err) { alert("åŒ¯å…¥å¤±æ•—: " + err.message); }
                input.value = ''; 
            };
            reader.readAsText(file);
        }

        function restoreNodePrototype(node) {
            node.isOnEquilibriumPath = false; 
            if(node.dx === undefined) node.dx = 0;
            if(node.dy === undefined) node.dy = 0;

            if (node.children) {
                node.children.forEach(restoreNodePrototype);
            }
            if (node.payoffs.length !== gameConfig.playerCount) {
                const newPay = Array(gameConfig.playerCount).fill(0);
                node.payoffs.forEach((p, i) => { if(i < newPay.length) newPay[i] = p; });
                node.payoffs = newPay;
            }
            return node;
        }


        // --- Settings Logic ---
        let tempConfig = {}; 
        function openSettings() {
            tempConfig = JSON.parse(JSON.stringify(gameConfig)); 
            document.getElementById('player-count-display').innerText = tempConfig.playerCount;
            renderSettingsInputs();
            document.getElementById('settings-modal').classList.add('modal-active');
        }
        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('modal-active');
        }
        function changePlayerCount(delta) {
            let newCount = tempConfig.playerCount + delta;
            if (newCount < 1) newCount = 1; if (newCount > 6) newCount = 6;
            tempConfig.playerCount = newCount;
            document.getElementById('player-count-display').innerText = newCount;
            if (tempConfig.playerNames.length < newCount) {
                for (let i = tempConfig.playerNames.length; i < newCount; i++) tempConfig.playerNames.push(`ç©å®¶ ${i + 1}`);
            } else if (tempConfig.playerNames.length > newCount) {
                tempConfig.playerNames = tempConfig.playerNames.slice(0, newCount);
            }
            renderSettingsInputs();
        }
        function renderSettingsInputs() {
            const container = document.getElementById('player-names-list');
            container.innerHTML = '';
            tempConfig.playerNames.forEach((name, idx) => {
                const div = document.createElement('div');
                div.className = "flex items-center gap-2";
                const colorDot = document.createElement('div');
                colorDot.className = "w-4 h-4 rounded-full flex-shrink-0";
                colorDot.style.backgroundColor = CONFIG.colors[idx % CONFIG.colors.length];
                const input = document.createElement('input');
                input.value = name;
                input.className = "flex-1 border border-slate-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none w-full";
                input.oninput = (e) => { tempConfig.playerNames[idx] = e.target.value; };
                div.appendChild(colorDot);
                div.appendChild(input);
                container.appendChild(div);
            });
        }
        function applySettings() {
            gameConfig = JSON.parse(JSON.stringify(tempConfig));
            updateTreePayoffs(treeData);
            closeSettings();
            renderTree(); 
        }
        function updateTreePayoffs(node) {
            const currentLen = node.payoffs.length;
            const targetLen = gameConfig.playerCount;
            if (currentLen < targetLen) {
                for (let i = 0; i < targetLen - currentLen; i++) node.payoffs.push(0);
            } else if (currentLen > targetLen) {
                node.payoffs = node.payoffs.slice(0, targetLen);
            }
            if (node.playerIdx >= targetLen) node.playerIdx = 0;
            node.children.forEach(updateTreePayoffs);
        }

        // --- Tree Management ---
        function addChild(parentNode) {
            const id = 'n-' + Math.random().toString(36).substr(2, 9);
            const newNode = new Node(id, parentNode.id);
            newNode.description = `é¸é … ${parentNode.children.length + 1}`;
            newNode.playerIdx = (parentNode.playerIdx + 1) % gameConfig.playerCount;
            parentNode.children.push(newNode);
            renderTree();
        }
        function removeNode(nodeId, parentId) {
            if (!parentId) return;
            const parent = findNode(treeData, parentId);
            if (parent) {
                parent.children = parent.children.filter(c => c.id !== nodeId);
                renderTree();
            }
        }
        function findNode(node, id) {
            if (node.id === id) return node;
            for (let child of node.children) {
                const found = findNode(child, id);
                if (found) return found;
            }
            return null;
        }
        function updateNodeData(id, type, value, index = 0) {
            const node = findNode(treeData, id);
            if (!node) return;
            if (type === 'desc') node.description = value;
            if (type === 'playerIdx') node.playerIdx = parseInt(value);
            if (type === 'payoff') node.payoffs[index] = parseFloat(value) || 0;
            if (type !== 'desc') {
                clearSolution(treeData);
                renderTree();
            }
        }

        // --- Logic: Backward Induction ---
        function solveGame() {
            clearSolution(treeData);
            backwardInduction(treeData);
            traceEquilibriumPath(treeData);
            renderTree();
        }
        function clearSolution(node) {
            node.bestChildId = null;
            node.isOnEquilibriumPath = false;
            node.children.forEach(clearSolution);
        }
        function backwardInduction(node) {
            if (node.children.length === 0) return [...node.payoffs];
            let bestVal = -Infinity;
            let bestPayoffs = null;
            let bestChildId = null;
            const currentPlayerIdx = node.playerIdx;
            for (let child of node.children) {
                const childResult = backwardInduction(child);
                const val = childResult[currentPlayerIdx];
                if (val > bestVal) {
                    bestVal = val; bestPayoffs = childResult; bestChildId = child.id;
                } else if (val === bestVal && bestPayoffs === null) {
                    bestPayoffs = childResult; bestChildId = child.id;
                }
            }
            node.bestChildId = bestChildId;
            return bestPayoffs;
        }
        function traceEquilibriumPath(node) {
            node.isOnEquilibriumPath = true;
            if (node.bestChildId) {
                const bestChild = node.children.find(c => c.id === node.bestChildId);
                if (bestChild) traceEquilibriumPath(bestChild);
            }
        }

        // --- UI Utils ---
        function adjustWidth(input) {
            const measurer = document.getElementById('text-measurer');
            if(!measurer) return;
            measurer.textContent = input.value || input.placeholder;
            const width = measurer.offsetWidth;
            input.style.width = Math.max(50, width + 12) + 'px';
        }

        // --- Rendering ---
        function renderTree() {
            const rootContainer = document.getElementById('tree-root');
            rootContainer.innerHTML = '';
            rootContainer.appendChild(buildNodeDOM(treeData));
            requestAnimationFrame(drawConnections);
        }

        function buildNodeDOM(node) {
            const container = document.createElement('div');
            container.className = 'tree-node-container';
            container.id = `node-container-${node.id}`;

            // V3.1: Create Group Wrapper for Label + NodeBox
            const nodeWrapper = document.createElement('div');
            nodeWrapper.className = 'node-wrapper';
            nodeWrapper.id = `node-wrapper-${node.id}`; // Add ID for drag updates
            
            // Apply Transform for independent movement on the wrapper
            nodeWrapper.style.transform = `translate(${node.dx || 0}px, ${node.dy || 0}px)`;
            
            // Add Drag Listener to the Wrapper (so clicking label or box initiates drag)
            nodeWrapper.onmousedown = (e) => startNodeDrag(e, node.id);
            nodeWrapper.ontouchstart = (e) => startNodeDrag(e, node.id);

            // Construct Label (if needed)
            if (node.parentId) {
                const label = document.createElement('input');
                label.value = node.description;
                label.className = "dynamic-width"; 
                // We don't need absolute positioning anymore because they are stacked in flex column
                
                setTimeout(() => adjustWidth(label), 0);
                label.oninput = (e) => {
                    adjustWidth(e.target);
                    updateNodeData(node.id, 'desc', e.target.value);
                };
                
                // Stop propagation for inputs to allow typing
                label.onmousedown = (e) => e.stopPropagation();
                label.ontouchstart = (e) => e.stopPropagation();
                
                nodeWrapper.appendChild(label);
            }

            // Construct Node Box
            const nodeBox = document.createElement('div');
            let cssClass = 'node-box ';
            cssClass += (node.children.length === 0) ? 'node-terminal ' : 'node-decision ';
            if (node.isOnEquilibriumPath) cssClass += ' highlight-equilibrium';
            nodeBox.className = cssClass;
            nodeBox.id = `node-visual-${node.id}`;

            if (node.children.length > 0) {
                // Decision Node
                const playerColor = CONFIG.colors[node.playerIdx % CONFIG.colors.length];
                let optionsHtml = '';
                gameConfig.playerNames.forEach((name, idx) => {
                    optionsHtml += `<option value="${idx}" ${node.playerIdx === idx ? 'selected' : ''}>${name}</option>`;
                });
                nodeBox.style.borderColor = playerColor;
                nodeBox.innerHTML = `
                    <div class="mb-1">
                        <select onchange="updateNodeData('${node.id}', 'playerIdx', this.value)" 
                            class="bg-transparent font-bold text-sm text-center outline-none cursor-pointer" 
                            style="color: ${playerColor}" onclick="event.stopPropagation()">
                            ${optionsHtml}
                        </select>
                    </div>
                    <div class="flex justify-center mt-2 gap-1 border-t pt-1 border-slate-100">
                        <button onclick="addChildWrapper('${node.id}')" class="text-xs bg-slate-100 hover:bg-blue-100 text-blue-600 rounded px-2 py-0.5" title="æ–°å¢" onmousedown="event.stopPropagation()">+</button>
                        ${!(!node.parentId) ? `<button onclick="removeNode('${node.id}', '${node.parentId}')" class="text-xs bg-slate-100 hover:bg-red-100 text-red-600 rounded px-2 py-0.5" title="åˆªé™¤" onmousedown="event.stopPropagation()">Ã—</button>` : ''}
                    </div>
                `;
            } else {
                // Terminal Node
                let payoffsHtml = '';
                gameConfig.playerNames.forEach((name, idx) => {
                    const color = CONFIG.colors[idx % CONFIG.colors.length];
                    payoffsHtml += `
                        <div class="payoff-grid" style="display:grid; grid-template-columns: auto 1fr; gap:4px; align-items:center;">
                            <div class="text-xs font-bold text-right truncate" style="color:${color}">${name[0]}:</div>
                            <input type="number" value="${node.payoffs[idx]}" 
                                class="editable-payoff text-sm" 
                                style="color:${color}"
                                onchange="updateNodeData('${node.id}', 'payoff', this.value, ${idx})" onmousedown="event.stopPropagation()">
                        </div>
                    `;
                });
                nodeBox.innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:2px;">${payoffsHtml}</div>
                    <div class="flex justify-between mt-2 pt-1 border-t border-slate-100">
                         <button onclick="addChildWrapper('${node.id}')" class="text-[10px] text-blue-500 hover:underline" onmousedown="event.stopPropagation()">æ“´å±•</button>
                         <button onclick="removeNode('${node.id}', '${node.parentId}')" class="text-[10px] text-red-500 hover:underline" onmousedown="event.stopPropagation()">åˆªé™¤</button>
                    </div>
                `;
            }

            nodeWrapper.appendChild(nodeBox);
            container.appendChild(nodeWrapper);

            if (node.children.length > 0) {
                const childrenCont = document.createElement('div');
                childrenCont.className = 'children-container';
                node.children.forEach(child => childrenCont.appendChild(buildNodeDOM(child)));
                container.appendChild(childrenCont);
            }
            return container;
        }

        function addChildWrapper(id) {
            const node = findNode(treeData, id);
            addChild(node);
        }

        // --- Drawing Lines ---
        function drawConnections() {
            const svg = document.getElementById('svg-layer');
            svg.innerHTML = ''; 
            
            // Helper to find the connection points relative to canvas
            const getCoords = (nodeId) => {
                // We target the node-visual (the box) for connection points
                const elem = document.getElementById(`node-visual-${nodeId}`);
                const container = document.getElementById('canvas-container');
                if (!elem || !container) return null;
                
                const rect = elem.getBoundingClientRect();
                const contRect = container.getBoundingClientRect();
                
                // Account for scroll
                return {
                    x: rect.left - contRect.left + container.scrollLeft + rect.width / 2,
                    y: rect.top - contRect.top + container.scrollTop + rect.height / 2,
                    bottom: rect.bottom - contRect.top + container.scrollTop,
                    top: rect.top - contRect.top + container.scrollTop
                };
            };

            const drawLine = (node) => {
                if (node.children.length > 0) {
                    const parentCoords = getCoords(node.id);
                    if (!parentCoords) return;
                    
                    node.children.forEach(child => {
                        const childCoords = getCoords(child.id);
                        if (!childCoords) return;
                        
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        const startX = parentCoords.x;
                        const startY = parentCoords.bottom;
                        const endX = childCoords.x;
                        const endY = childCoords.top;
                        
                        // Bezier
                        const cp1y = startY + (endY - startY) / 2;
                        const cp2y = endY - (endY - startY) / 2;
                        const d = `M ${startX} ${startY} C ${startX} ${cp1y}, ${endX} ${cp2y}, ${endX} ${endY}`;
                        
                        path.setAttribute("d", d);
                        let className = "connection";
                        const isOptimalMove = (node.bestChildId === child.id);
                        if (isOptimalMove) {
                            if (node.isOnEquilibriumPath) className += " equilibrium-path";
                            else className += " off-path-optimal";
                        }
                        path.setAttribute("class", className);
                        svg.appendChild(path);
                        
                        drawLine(child);
                    });
                }
            };
            
            // Adjust SVG size to fit content
            const rootEl = document.getElementById('tree-root');
            svg.style.width = Math.max(rootEl.scrollWidth + 200, window.innerWidth) + 'px';
            svg.style.height = Math.max(rootEl.scrollHeight + 200, window.innerHeight) + 'px';
            
            drawLine(treeData);
        }

        function zoom(delta) {
            scale = Math.max(0.4, Math.min(2, scale + delta));
            document.getElementById('tree-root').style.transform = `scale(${scale})`;
            drawConnections();
        }
        function resetZoom() {
            scale = 1;
            document.getElementById('tree-root').style.transform = `scale(1)`;
            drawConnections();
        }

        window.addEventListener('resize', drawConnections);
        init();
    </script>
</body>
</html>
